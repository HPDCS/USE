PROGRAMMA ORIGINALE: Il programma non prevede meccanismi per interrompere un thread dal suo lavoro, ne in modo sincrono ne in modo asincrono.

CONSTANT_CHILD_INVALIDATION:se abilitato,modifica la funzione is_valid in modo tale da aggiungere il predicato "il padre dovrà eventually essere rieseguito?" che quindi permette l'invalidazione degli eventi figli sia nel caso in cui il padre è già stato ri-eseguito(la sua epoca è aumentata rispetto alla precedente esecuzione) e sia nel caso in cui il padre dovrà essere rieseguito.

IPI_PREEMPT_COUNTER: macro che dà la possibilità al programma di scegliere in modo sincrono i punti del codice in cui una interruzione,di qualsiasi tipo(sincrona/asincrona), può accadere. L'interruzione può avvenire solo quando il preemption_counter è 0.Aumentare il preemption counter assicura che in tutte le funzioni innestate che vengono chiamate non ci siano interruzioni.
Il programma non è ancora in grado di interrompersi.


IPI_LONG_JMP: macro che dà la possibilità al programma di fare delle long_jmp in qualsiasi scenario,ma solo quando il preempt_counter è 0.In alcuni punti critici del codice,fare long_jmp non è safe.Di fatto con questa macro abilitata il programma supporta il meccanismo delle interruzioni sincrone.
Lasciare il valore di counter a 0 se si vuole chiamare la long_jmp come se fosse una normale funzione.

IPI_HANDLE_INTERRUPT: macro che implementa il supporto per settare un LP come valido/invalido,utile per permettere l'interruzione asincrona/sincrona in scenari critici,quando il preemption counter è 0.
Grazie a questa macro è possibile in seguito all'interruzione settare un LP come invalido per poterlo ripristinare correttamente appena possibile.
Si preoccupa di invalidare e ripristinare lo stato dell'LP in seguito a qualsiasi interruzione asincrona/sincrona.
Non si preoccupa di gestire l'evento current_msg interrotto(aumentare numero frame,inserirlo in coda locale,settarlo come interrotto,farlo apparire nel futuro ecc),deve essere fatto esplicitamente da altre macro.

IPI_SUPPORT: macro che dà la possibilità al programma di inviare e ricevere interruzioni asincrone, in modo safe.
Le interruzioni possono essere inviate da un thread ad un altro in qualsiasi scenario. Le interruzioni vengono effettivamente catturate quando il thread destinatario ha preemption counter pari a 0 e sta eseguendo una ProcessEvent.

IPI_SYNC_CHECK:macro che se abilitata,esegue dei check in modo sincrono che, se risultano veri, fanno eseguire una interruzione sincrona.Prima di eseguire l'interruzione sincrona è necessario settare l'LP come invalido e gestire correttamente current_msg interrotto.

IPI_POSTING:posta informazioni prioritarie per LP che possono essere lette in modo safe quando si ha il lock sull'LP

TODO:
-valutare se inserire riaggiornamento di until_ts con valore globale ad ogni silent_execution
-valutare check sincroni prima di invalidare lo stato con l'esecuzione di un evento
-ipi che interrompe execution in past,ma si potrebbe evitare l'interruzione e fermarsi prima nella s.e.,vedere come risolvere
-raggruppare il codice in funzioni
-raggruppare i debug in funzioni check
-aggiustare debug con old_valid_bound e bound_pre_rollback
-verificare che modifiche non impattano LP_STATE_ONGVT
-è possibile far coincidere old_valid_bound con bound_pre_rollback per quanto riguarda LP_STATE_ONGVT?

-postare info su anti_msg in past quando non è possibile eseguire try_lock(solo ts o pointer ad evento,ma è più complicato e inefficiente)
-inserire statistiche basate su grana degli eventi in base al type
-modello decisionale:livello speculatività,stato simulazione lp dest(stateready,staterollback,bound,evento in esecuzione ecc),lp in processevent,residual time ecc
-print_statistics stampa solo i valori non fa nessun calcolo,nemmeno sottrazioni
-studiare statistics post lp data e fare in modo che non si sfalsano le statistiche con l'interruzione


-operazioni che dipendono dalle statistiche potrebbero funzionare meglio se le statistiche vengo calcolate come si deve,a volte vengono calcolate male nel codice es rollback_length.
-varie statistiche non vengono calcolate adeguatamente anche nel caso in cui non ci siano interruzioni
-MAX_LP 2048 non viene gestito correttamente,se viene passato un numero più grande il programma non termina con errore,as expected!!
-se si vedono i riferimenti alla macro MAX_LPS si vede che non viene utilizzata adeguatamente, per la macro MAX_SOBJS viene allocata troppa memoria,basterebbe n_prc_tot?(force full mai utilizzata,allocazione globale statica)
-rivedere il calcolo delle statistiche,rinominare alcuni campi della struct in modo tale da suddividerle per thread per LP e da calcolare in modo ordinato rispetto alla struct stat64_t il tempo medio o numero medio deve avere mean nel nome.
-counter_rollbacks_length viene sommata 2 volte in gather_statistics
-la probabilità che su interruzione venga interrotto un altro thread dell'applicazione in un sistema scarico è bassa,in ogni caso se succede possiamo sempre sfruttare lo standing_ipi
-la read dal device dev/random può essere bloccante e fa si che il programma impieghi molto tempo per finire di completare,tutto il tempo è dedicato a leggere dal dev/random,utilizzare dev/urandom che non è bloccante,ma restituisce una sequenza di byte randomici di minore qualità rispetto alla dev/random, in alternativa creare a mano il file di configurazione in modo tale che legga sempre lo stesso numero
-righe 403,404 non necessarie in numerical.c
-nel programma originale mettere volatile alla variabile ready_wt
-nel programma originale modificare il node->counter(preso dall'evento precedente) nella fetch con event->tiebreaker(preso dall'evento corrente)
-postare info in base al livello di speculatività

-inserire barriera leggera di memoria a tutti gli aggiornamenti del counter(+1 -1). Altrimenti un riordino delle istruzioni crea problemi!!
-inserire barriera di memoria tra scrittura unposted e flush sulla coda globale,per garantire che ogni evento inserito in coda globale non postato non sia mai flaggato come Posted
-micro bug in ONGVT_PERIOD legato all'aggiornamento del commit_ts e commit_tb horizon è possibile impostare il tb non correlato con il timestamp e per questo si vede la fine simulazione su un evento non safe!!


-idea:
-cfv su interruzione solo se info postata è buona(mettere dentro il trampolino questa logica con chiamata diretta alla funzione, e poi successivamente pensare all'assembly)
-rimuovere father frame,attualmente non utilizzato e se si utilizza la IPI_CONSTANT_CHILD_INVALIDATION non serve più father frame

Osservazioni:
-se nella simulazione il master seed è sempre lo stesso e tutti gli eventi hanno ts diverso(tb=1) la simulazione termina sempre con lo stesso stato finale e stato transitorio?
-se vengono generati eventi con lo stesso ts (tb>1), è impossibile avere che la simulazione finisca sempre alla stessa maniera, o ciò è valido solo se vengono generati almeno 1 volta 2 eventi con lo stesso ts per lo stesso LP?(se vengono generati eventi con stesso ts su diversi LP la simulazione può finire allo stesso modo)
-in base alle risposte delle precedenti domande potrebbe essere utile calcolare il numero di volte che i ts sono uguali(per LP o in generale),se con un certo seme iniziale stessi thread e stesso numero di LP si ottiene che i ts sono tutti diversi allora essi saranno sempre tutti diversi e ci permette di ottenere simulazioni testabili.
-se viene generato un nodo con ts x e successivamente rimosso e poi viene generato un altro nodo con ts x risulta che hanno diverso tb o no?
-tra 2 nbc_prune gli eventi non vengono collezionati
-la variabile safe può avere valori diversi tra i thread(il thread che esegue un evento e ha il lock potrebbe vedere quell'evento come non safe)
-checkpoint recalculation capace che funziona male perché il rollback lenght è lungo attualmente,siccome arriva sempre al destination ts e non si ferma al primo evento invalido.(inoltre non è necessario ricalcolarlo se è stata attivata la modalità LP_STATE_ON_GVT è un rollback spontaneo)

-prune localqueue with ts old è dead code,mai chiamato da nessuno.
-rimuovere stop silent e tutto ciò che dipende da essa in silent exec
-a volte macro innestate sono necessarie se la macro inner ha un else
-counter inizialmente è 0,se voglio essere interrompibile non faccio niente,se non voglio essere interrompibile aumento il counter eseguo e poi decremento.
-hash su LP_state
-restore state non viene chiamata da nessuno.
-l'indirizzo current_base_pointer è sempre lo stesso e non serve riaggiornalo(confusione,diminuisce la leggibilità del codice)
-check di integrità su LP_state e checkpoint per essere sicuri che non siano corrotti e che siano coerenti(tramite hash o altro)
-current_base_pointer è null,viene allocato una sola volta con l'evento INIT nella ProcessEvent
-checkpoint recalculation non è attivo di default,dipende dal rollback length,ma quest'ultimo viene calcolato male.
-i checkpoint vengono buttati durante il rollback se LP è nello stato LP_STATE_ROLLBACK, non vengono buttati in LP_STATE_ONGVT
-l'evento init viene allocato normalmente,inizializzato e passato alla processEvent con init come parametro,l'evento init non viene mai committato ma non è un problema perché non appare in coda globale,inoltre successivamente alla sua esecuzione e incremento dei frame dell'LP viene forzato un checkpoint,quindi è sempre possibile ritornare ad un punto iniziale con evento init eseguito.Questo fa pensare che è safe spostare il log_state dopo l'incremento dei frame dell'LP

Osservazioni su fine simulazione/onGVT
-non generare più eventi se la simulazione è finita per un LP,se un altro LP non può finire la simulazione in questo modo, la simulazione dovrebbe finire per quell'LP se non trova più eventi in coda??Ipotizzare in questo caso che LP che finisce generi degli eventi prodotti con ts molto grande e successivo all'istante di completamento dell'altro LP,in questo modo LP o non ha eventi entro la sua condizione di fine oppure esegue un evento con ts infinito per finirla,e prima o poi andrà in rollback
-inserire un nodo in coda locale con ts infinito per ogni LP, in questo modo la simulazione può finire per ogni LP,perché se non si riescono a fetchare eventi nel futuro è possibile eseguire gli eventi nella coda locale con ts infinito per farla finire.
-dividere gli LP tra quelli che hanno realmente finito e quelli che dovranno finire, se un LP finisce in modo commit ok,se finisce in modo speculativo ok,si ferma o fetcherà un evento anti/new_evt oppure tenderà ad andare in commit anche lui, se per un certo LP non ci sono più eventi la sua simulazione si sospende e quando tra i restanti LP ci si accorge che tutti devono finire allora la simulazione termina come se avessero eseguito l'evento con ts infinito.
-se simulazione finita in commit o modo speculativo non si fetchano più eventi nel futuro nemmeno evento FINAL con ts infinito
-se simulazione non è terminata,si fetcherà prima o poi l'evento con ts INFINITO che andrà in commit,se l'evento con ts infinito va in commit allora la simulazione è finita in modo commit.
sui nodi con ts infinito si potrebbe decidere di usare tb per differenziarli e avere sempre nodi con ts diverso!!!
-eventi con ts infinito non diventeranno mai invalidi,ma possono essere rieseguiti,vengono rimossi dalla coda globale solo quando vengono committati.
