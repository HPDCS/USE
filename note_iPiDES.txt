TODO:
-rivedere tutti i punti in cui avviene la enter/exit preemptable/unpreemptable e vedere se ci sono problemi ad interrompere prima/dopo aver incrementato/decrementato specialmente ongvt
-togliere check su increment del preemption counter

-ricontrollare tutte le statistiche nuove e vecchie, soprattutto quelle interrompibili che sono correlate


-rimuovere standing ipi
-pointer a funzione per i check su decrement,se parametro è NULL viene chiamata solo la funzione di default,la funzione passata deve essere una preoperazione per la gestione dell'interrupt.

-rafforzare check in fetch.c per deliverare gli ipi?

-vedere la parte dei seed come viene ripristinata per capire perché le 2 scritture della random non sono interrompibili.(gdb restituisce seed2=null segmentation fault)

-rilassare preemption_counter sulla enqueue della coda globale in queue_deliver_msgs
-constant_child_invalidation da debuggare,degrada le performance ma non a causa delle istruzioni atomiche












Osservazioni:
-la probabilità che su interruzione venga interrotto un altro thread dell'applicazione in un sistema scarico è bassa,in ogni caso se succede possiamo sempre sfruttare lo standing_ipi
-se nella simulazione il master seed è sempre lo stesso e tutti gli eventi hanno ts diverso(tb=1) la simulazione termina sempre con lo stesso stato finale e stato transitorio?
-se vengono generati eventi con lo stesso ts (tb>1), è impossibile avere che la simulazione finisca sempre alla stessa maniera, o ciò è valido solo se vengono generati almeno 1 volta 2 eventi con lo stesso ts per lo stesso LP?(se vengono generati eventi con stesso ts su diversi LP la simulazione può finire allo stesso modo)
-in base alle risposte delle precedenti domande potrebbe essere utile calcolare il numero di volte che i ts sono uguali(per LP o in generale),se con un certo seme iniziale stessi thread e stesso numero di LP si ottiene che i ts sono tutti diversi allora essi saranno sempre tutti diversi e ci permette di ottenere simulazioni testabili.
-se viene generato un nodo con ts x e successivamente rimosso e poi viene generato un altro nodo con ts x risulta che hanno diverso tb o no?
-tra 2 nbc_prune gli eventi non vengono collezionati
-la variabile safe può avere valori diversi tra i thread(il thread che esegue un evento e ha il lock potrebbe vedere quell'evento come non safe)
-a volte macro innestate sono necessarie se la macro inner ha un else
-current_base_pointer è null,viene allocato una sola volta con l'evento INIT nella ProcessEvent
-i checkpoint vengono buttati durante il rollback se LP è nello stato LP_STATE_ROLLBACK, non vengono buttati in LP_STATE_ONGVT
-l'evento init viene allocato normalmente,inizializzato e passato alla processEvent con init come parametro,l'evento init non viene mai committato ma non è un problema perché non appare in coda globale,inoltre successivamente alla sua esecuzione e incremento dei frame dell'LP viene forzato un checkpoint,quindi è sempre possibile ritornare ad un punto iniziale con evento init eseguito.Questo fa pensare che è safe spostare il log_state dopo l'incremento dei frame dell'LP












Osservazioni su fine simulazione/onGVT
-non generare più eventi se la simulazione è finita per un LP,se un altro LP non può finire la simulazione in questo modo, la simulazione dovrebbe finire per quell'LP se non trova più eventi in coda??Ipotizzare in questo caso che LP che finisce generi degli eventi prodotti con ts molto grande e successivo all'istante di completamento dell'altro LP,in questo modo LP o non ha eventi entro la sua condizione di fine oppure esegue un evento con ts infinito per finirla,e prima o poi andrà in rollback
-inserire un nodo in coda locale con ts infinito per ogni LP, in questo modo la simulazione può finire per ogni LP,perché se non si riescono a fetchare eventi nel futuro è possibile eseguire gli eventi nella coda locale con ts infinito per farla finire.
-dividere gli LP tra quelli che hanno realmente finito e quelli che dovranno finire, se un LP finisce in modo commit ok,se finisce in modo speculativo ok,si ferma o fetcherà un evento anti/new_evt oppure tenderà ad andare in commit anche lui, se per un certo LP non ci sono più eventi la sua simulazione si sospende e quando tra i restanti LP ci si accorge che tutti devono finire allora la simulazione termina come se avessero eseguito l'evento con ts infinito.
-se simulazione finita in commit o modo speculativo non si fetchano più eventi nel futuro nemmeno evento FINAL con ts infinito
-se simulazione non è terminata,si fetcherà prima o poi l'evento con ts INFINITO che andrà in commit,se l'evento con ts infinito va in commit allora la simulazione è finita in modo commit.
sui nodi con ts infinito si potrebbe decidere di usare tb per differenziarli e avere sempre nodi con ts diverso!!!
-eventi con ts infinito non diventeranno mai invalidi,ma possono essere rieseguiti,vengono rimossi dalla coda globale solo quando vengono committati.